While I don't think I have the optimal solution to the problem, I hope to share some insights that might help you get to the optimal solution faster. While designing the problem, I was tempted to add another layer of complexity, by letting Yang place $s$ chess pieces on the board initially, that could not move. Wherever these pieces could make a legal move (without captures) they would be considered adjacent to. So a knight at the center of the board would be adjacent to an additional $8$ squares, totaling $16$. It was from this chess idea, that I was able to find out about the `0x88` board implementation, where instead of storing the information of the board on an $64$-sized array, chess programmers instead use $2$ $8$ x $8$ grids next to each other, as in, a $128$-sized array. For the index `i`, then, `i ^ 0x88` gives a boolean check of whether the index is on the board or off the board. While the chess idea didn't make the cut, it made sense to model the board representation for the problem a little differently here. 

I start off by making an $(n + 2)$ x $(n + 2)$ grid, with all of its edges marked _dead_. This saves us from having to deal with edge cases, _literally_. Another thing to notice with the game is that there are some inherent patterns that show up. You can look them up, but the rundown is that there are _still life_, _oscillator_, and _spaceship_ patterns; out of the three _spaceships_ cannot be sustained on a finite grid, which means we only have to check whether a particular board repeats to terminate our loop and increment $r$. This can be done easily with a map, since C++ has a `==` operator for a `std::vector`, but I believe if we write our own hashing function, a `std::unordered_map` could be used too. 

The next part is to find the motif itself; my approach was pretty much brute-forcing it, and at one point I did think of implementing string searching algorithms, but I didn't see how the gaps in the indices would lend to a neat and efficient program, so I stuck to using array offsets for my solution. The index for any cell is given by $(n + 2)*i + j$ where $i$ is the index of the row, and $j$ is the index for the column. And we basically use two indices, $p$ for the board, $i$ for the motif. Anytime the index $i$ goes beyond the equivalence class $(q - r)\text{mod q}$, we increment $i$ and $p$ to go to the next _"row"_. For every passed index $p$, we loop over $i$ and $p$, checking all $q - r$ x $q - r$ elements that start from that index for equality (or inequality for Yang). We limit our passed indices such that within the loop, $p$ never attains an out of bounds value (including the dead cells at the edge of our board). 

Overall, finding the motif on a board will take $O(n^{2} (q)^2)$ and we do this for each generation. Let $\sigma(n)$ be the worst-case time complexity for iterating through the generations until a previous or dead generation is obtained. And again, if neither motif is found in any generation, we iterate through all possible $q$, giving an overall time-complexity of $O(n^{2} (q)^{3} \sigma(n))$. Minor optimizations aside, I don't believe a better time-complexity is achievable, given that the original game is mathematically undecidable on an infinite grid. 

A fun exercise is to look at this game from a game theory perspective, where both players are infinitely intelligent. After the initial conditions are set, the game has a finite number of moves to get to an endpoint. Yang must decide on a board that has, for every submatrix, a bit-flipped version contained within the matrix. As I am only finitely intelligent, finding whether such a board exists for a given $n$ is left as an open problem. 